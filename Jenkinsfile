pipeline {
    agent any // Specifies that Jenkins can use any available agent

    tools {
        // These names must match what you configured in Jenkins Global Tool Configuration
        maven 'Maven3.9.9' // Or your configured Maven name
        jdk 'OpenJDK21'      // Or your configured JDK name
    }

    environment {
        DOCKERHUB_CREDENTIALS_ID = 'dockerhub-credentials' // ID of your Docker Hub credentials in Jenkins
        GITHUB_CREDENTIALS_ID = 'github-credentials'     // ID of your GitHub credentials (if needed for other git operations, checkout usually handles it)
        DOCKER_IMAGE_NAME = "vikasvs007/my-ci-cd-app" // Replace with your Docker Hub username
        // POM_VERSION = readMavenPom().getVersion() // Uncomment to use version from pom.xml
        // IMAGE_TAG = "${POM_VERSION}.${env.BUILD_NUMBER}" // Example for versioned tag
        IMAGE_TAG = "latest" // Or use a dynamic tag like "latest-${env.BUILD_NUMBER}"
    }

    stages {
        stage('Checkout') {
            steps {
                echo 'Checking out code from GitHub...'
                // Clean the workspace before checkout
                cleanWs()
                git branch: 'main',
                    url: 'https://github.com/vikasvs007/my-ci-cd-app.git', // Replace with your repo URL
                    credentialsId: env.GITHUB_CREDENTIALS_ID // Use the credentials ID for private repos
            }
        }

        stage('Build') {
            steps {
                echo 'Building the application...'
                // For Windows agents: bat 'mvn clean install'
                // For Linux/macOS agents:
                sh 'mvn clean install'
            }
            post {
                always {
                    // Archive JUnit test results
                    junit 'target/surefire-reports/*.xml'
                    // Archive the JAR file
                    archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
                }
            }
        }

        // Optional: Separate Test Stage if you want more control or specific test commands
        // stage('Test') {
        //     steps {
        //         echo 'Running tests...'
        //         sh 'mvn test' // 'mvn install' already runs tests by default
        //     }
        // }

        stage('Build Docker Image') {
            steps {
                script {
                    echo "Building Docker image: ${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}"
                    // Ensure the JAR file from the build stage is available in the context
                    // The Dockerfile's COPY command will look for target/*.jar relative to the workspace root
                    docker.withRegistry('https://index.docker.io/v1/', env.DOCKERHUB_CREDENTIALS_ID) {
                        def customImage = docker.build("${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}", "--build-arg JAR_FILE=target/my-ci-cd-app-${readMavenPom().getVersion()}.jar .")
                        // The JAR_FILE build-arg must match the actual name generated by Maven
                        // Or, ensure your Dockerfile's ARG JAR_FILE default or the COPY command matches
                        // A simpler approach if the JAR name is consistent with artifactId-version.jar:
                        // def customImage = docker.build("${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}", ".")
                    }
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    echo "Pushing Docker image ${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG} to Docker Hub..."
                    docker.withRegistry('https://index.docker.io/v1/', env.DOCKERHUB_CREDENTIALS_ID) {
                        docker.image("${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}").push()
                    }
                }
            }
        }

        // Optional: Deployment Stage
        // stage('Deploy') {
        //     steps {
        //         echo 'Deploying application...'
        //         // Add your deployment steps here (e.g., kubectl apply, ssh to server and run docker-compose up, etc.)
        //     }
        // }
    }

    post {
        // This block executes after all stages, regardless of outcome
        always {
            echo 'Pipeline finished. Sending email notification...'
            emailext (
                subject: "Build ${currentBuild.currentResult}: Project ${env.JOB_NAME} - Build #${env.BUILD_NUMBER}",
                body: """<p>Project: ${env.JOB_NAME}</p>
                         <p>Build Number: ${env.BUILD_NUMBER}</p>
                         <p>Build Status: ${currentBuild.currentResult}</p>
                         <p>Build URL: <a href="${env.BUILD_URL}">${env.BUILD_URL}</a></p>
                         <p>Changes:</p>
                         <pre>${currentBuild.changeSets.collect { it.msg + ' (' + it.author + ')' }.join('\\n')}</pre>
                         <hr/>
                         <p>Check console output at <a href="${env.BUILD_URL}console">${env.BUILD_URL}console</a></p>""",
                to: "your.email@example.com, another.admin@example.com", // Replace with recipient email addresses
                recipientProviders: [
                    [$class: 'DevelopersRecipientProvider'], // Email committers
                    [$class: 'RequesterRecipientProvider']  // Email user who triggered the build
                ],
                mimeType: 'text/html',
                attachLog: true,
                compressLog: true
            )
            // Clean up workspace
            cleanWs()
        }
        success {
            echo 'Pipeline executed successfully!'
            // You could add specific success notifications here if needed
        }
        failure {
            echo 'Pipeline failed.'
            // You could add specific failure notifications or actions here
        }
        unstable {
            echo 'Pipeline is unstable (e.g., tests failed but build succeeded).'
        }
    }
}